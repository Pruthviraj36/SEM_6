#!/usr/bin/env node

const { program } = require('commander');
const chalk = require('chalk');
const UI = require('./lib/ui');
const GitOperations = require('./lib/git-operations');
const Config = require('./lib/config');
const Setup = require('./lib/setup');
const AICommitGenerator = require('./lib/ai-commit');

const config = new Config();
const setup = new Setup();

// Check for first run
async function checkFirstRun() {
    if (!config.configExists()) {
        console.log(chalk.gray('\n  [') + chalk.green('*') + chalk.gray('] First time using Git Neo in this project!\n'));
        await setup.run();
        console.log('');
    }
}

// Load config and create instances
const projectConfig = config.loadConfig();
const git = new GitOperations(projectConfig);
const ui = new UI(projectConfig);

// If no arguments provided, start interactive mode FIRST
if (process.argv.length === 2) {
    checkFirstRun().then(() => {
        ui.start();
    });
} else {
    // Command-line mode - setup Commander
    program
        .name('git-neo')
        .description(chalk.cyan('Git Neo - Enter the Git Matrix'))
        .version('1.0.2')
        .hook('preAction', async () => {
            // Skip setup check for setup command itself
            if (process.argv[2] !== 'setup') {
                await checkFirstRun();
            }
        });

    // Setup command
    program
        .command('setup')
        .description('Run setup wizard or reconfigure')
        .action(async () => {
            if (config.configExists()) {
                await setup.reconfigure();
            } else {
                await setup.run();
            }
        });

    // Smart push command
    program
        .command('push')
        .description('Smart push: add, commit, and push in one command')
        .argument('[message]', 'commit message')
        .action(async (message) => {
            if (!message) {
                console.log(chalk.red('âœ— Commit message is required'));
                console.log(chalk.gray('Usage: git-neo push "your commit message"'));
                process.exit(1);
            }

            const result = await git.smartPush(message);
            if (!result.success) {
                console.log(chalk.red(`âœ— ${result.message}`));
                process.exit(1);
            }
        });

    // Commit command (without push)
    program
        .command('commit')
        .description('Add and commit changes (without push)')
        .argument('[message]', 'commit message')
        .action(async (message) => {
            if (!message) {
                console.log(chalk.red('âœ— Commit message is required'));
                console.log(chalk.gray('Usage: git-neo commit "your commit message"'));
                process.exit(1);
            }

            const result = await git.smartCommit(message);
            if (!result.success) {
                console.log(chalk.red(`âœ— ${result.message}`));
                process.exit(1);
            }
        });

    // AI Commit command
    program
        .command('ai-commit')
        .description('Generate AI-powered commit message and commit')
        .option('-p, --push', 'push after commit')
        .action(async (options) => {
            const aiGenerator = new AICommitGenerator(projectConfig);

            if (!aiGenerator.isAvailable()) {
                console.log(chalk.yellow('\nâš  AI commit not configured\n'));
                console.log(aiGenerator.getSetupInstructions());
                process.exit(1);
            }

            // Get diff
            const diffResult = await git.git.diff();
            if (!diffResult || diffResult.trim().length === 0) {
                console.log(chalk.yellow('âœ— No changes to commit'));
                process.exit(1);
            }

            // Generate AI commit message
            const result = await aiGenerator.generateCommitMessage(diffResult);

            if (!result.success) {
                console.log(chalk.red(`âœ— ${result.message}`));
                process.exit(1);
            }

            console.log(chalk.green('\nğŸ¤– AI Generated Commit Message:'));
            console.log(chalk.white(`   "${result.message}"\n`));

            // Ask for confirmation
            const inquirer = require('inquirer');
            const { action } = await inquirer.prompt([
                {
                    type: 'list',
                    name: 'action',
                    message: 'What would you like to do?',
                    choices: [
                        { name: 'Use this message', value: 'use' },
                        { name: 'Edit this message', value: 'edit' },
                        { name: 'Generate new message', value: 'regenerate' },
                        { name: 'Cancel', value: 'cancel' }
                    ]
                }
            ]);

            let finalMessage = result.message;

            if (action === 'cancel') {
                console.log(chalk.gray('\nCancelled.\n'));
                process.exit(0);
            } else if (action === 'edit') {
                const { edited } = await inquirer.prompt([
                    {
                        type: 'input',
                        name: 'edited',
                        message: 'Edit commit message:',
                        default: result.message
                    }
                ]);
                finalMessage = edited;
            } else if (action === 'regenerate') {
                const newResult = await aiGenerator.generateCommitMessage(diffResult);
                if (newResult.success) {
                    finalMessage = newResult.message;
                    console.log(chalk.green('\nğŸ¤– New AI Generated Message:'));
                    console.log(chalk.white(`   "${finalMessage}"\n`));
                }
            }

            // Commit with the message
            if (options.push) {
                const commitResult = await git.smartPush(finalMessage);
                if (!commitResult.success) {
                    console.log(chalk.red(`âœ— ${commitResult.message}`));
                    process.exit(1);
                }
            } else {
                const commitResult = await git.smartCommit(finalMessage);
                if (!commitResult.success) {
                    console.log(chalk.red(`âœ— ${commitResult.message}`));
                    process.exit(1);
                }
            }
        });

    // Pull command
    program
        .command('pull')
        .description('Pull changes from remote')
        .option('-r, --remote <remote>', 'remote name', 'origin')
        .option('-b, --branch <branch>', 'branch name')
        .action(async (options) => {
            const result = await git.pull(options.remote, options.branch);
            if (!result.success) {
                console.log(chalk.red(`âœ— ${result.message}`));
                process.exit(1);
            }
        });

    // Clone command
    program
        .command('clone <url>')
        .description('Clone a repository')
        .argument('[directory]', 'target directory')
        .action(async (url, directory) => {
            const result = await git.clone(url, directory);
            if (!result.success) {
                console.log(chalk.red(`âœ— ${result.message}`));
                process.exit(1);
            }
        });

    // Init command
    program
        .command('init')
        .description('Initialize a new Git repository')
        .action(async () => {
            const result = await git.init();
            if (!result.success) {
                console.log(chalk.red(`âœ— ${result.message}`));
                process.exit(1);
            }
        });

    // Log command
    program
        .command('log')
        .description('Show commit history')
        .option('-n, --number <count>', 'number of commits to show', '10')
        .action(async (options) => {
            const count = parseInt(options.number);
            const result = await git.log(count);
            if (!result.success) {
                console.log(chalk.red(`âœ— ${result.message}`));
                process.exit(1);
            }
        });

    // Diff command
    program
        .command('diff')
        .description('Show changes')
        .argument('[file]', 'specific file to diff')
        .action(async (file) => {
            const result = await git.diff(file);
            if (!result.success) {
                console.log(chalk.red(`âœ— ${result.message}`));
                process.exit(1);
            }
        });

    // Fetch command
    program
        .command('fetch')
        .description('Fetch from remote')
        .option('-r, --remote <remote>', 'remote name', 'origin')
        .action(async (options) => {
            const result = await git.fetch(options.remote);
            if (!result.success) {
                console.log(chalk.red(`âœ— ${result.message}`));
                process.exit(1);
            }
        });

    // Branch commands
    const branchCmd = program
        .command('branch')
        .description('Branch management');

    branchCmd
        .command('list')
        .alias('ls')
        .description('List all branches')
        .action(async () => {
            const result = await git.listBranches();
            if (result.success) {
                console.log(chalk.bold.cyan('\nBranches:'));
                Object.entries(result.branches).forEach(([name, info]) => {
                    const prefix = name === result.current ? chalk.green('* ') : '  ';
                    console.log(prefix + name);
                });
                console.log('');
            } else {
                console.log(chalk.red(`âœ— ${result.message}`));
                process.exit(1);
            }
        });

    branchCmd
        .command('create <name>')
        .description('Create a new branch')
        .action(async (name) => {
            const result = await git.createBranch(name);
            if (!result.success) {
                console.log(chalk.red(`âœ— ${result.message}`));
                process.exit(1);
            }
        });

    branchCmd
        .command('switch <name>')
        .alias('sw')
        .description('Switch to a branch')
        .action(async (name) => {
            const result = await git.switchBranch(name);
            if (!result.success) {
                console.log(chalk.red(`âœ— ${result.message}`));
                process.exit(1);
            }
        });

    branchCmd
        .command('delete <name>')
        .alias('del')
        .option('-f, --force', 'force delete')
        .description('Delete a branch')
        .action(async (name, options) => {
            const result = await git.deleteBranch(name, options.force);
            if (!result.success) {
                console.log(chalk.red(`âœ— ${result.message}`));
                process.exit(1);
            }
        });

    // Merge command
    program
        .command('merge <branch>')
        .description('Merge a branch into current branch')
        .action(async (branch) => {
            const result = await git.mergeBranch(branch);
            if (!result.success) {
                if (result.conflicts) {
                    console.log(chalk.red('\nâœ— Merge conflicts in:'));
                    result.conflicts.forEach(file => {
                        console.log(chalk.yellow(`  - ${file}`));
                    });
                    console.log(chalk.gray('\nResolve conflicts manually and commit\n'));
                } else {
                    console.log(chalk.red(`âœ— ${result.message}`));
                }
                process.exit(1);
            }
        });

    // Status command
    program
        .command('status')
        .alias('st')
        .description('Show repository status')
        .action(async () => {
            const result = await git.displayStatus();
            if (!result.success) {
                console.log(chalk.red(`âœ— ${result.message}`));
                process.exit(1);
            }
        });

    // Parse arguments for command-line mode
    program.parse();
}

// Graceful shutdown handlers
process.on('SIGINT', () => {
    console.log(chalk.gray('\n\n  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'));
    console.log(chalk.gray('  [') + chalk.red('!') + chalk.gray('] Git Neo interrupted by user'));
    console.log(chalk.gray('  [') + chalk.white('*') + chalk.gray('] Exiting the Matrix...'));
    console.log(chalk.gray('  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n'));
    process.exit(0);
});

process.on('SIGTERM', () => {
    console.log(chalk.gray('\n\n  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'));
    console.log(chalk.gray('  [') + chalk.red('!') + chalk.gray('] Git Neo terminated'));
    console.log(chalk.gray('  [') + chalk.white('*') + chalk.gray('] Goodbye!'));
    console.log(chalk.gray('  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n'));
    process.exit(0);
});
