const chalk = require('chalk');
const GitOperations = require('./git-operations');
const prompts = require('./prompts');
const AICommitGenerator = require('./ai-commit');

class UI {
    constructor(config = null) {
        this.git = new GitOperations(config);
        this.aiGenerator = new AICommitGenerator(config);
    }

    displayWelcome() {
        console.clear();
        console.log(chalk.green(`
   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—    â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— 
  â–ˆâ–ˆâ•”â•â•â•â•â• â–ˆâ–ˆâ•‘â•šâ•â•â–ˆâ–ˆâ•”â•â•â•    â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—
  â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘       â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘
  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘       â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘
  â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘       â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•
   â•šâ•â•â•â•â•â• â•šâ•â•   â•šâ•â•       â•šâ•â•  â•šâ•â•â•â•â•šâ•â•â•â•â•â•â• â•šâ•â•â•â•â•â• 
        `));
        console.log(chalk.gray('  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'));
        console.log(chalk.gray('  â”‚') + chalk.white('  Enter the Matrix v1.0.2') + chalk.gray('                  â”‚'));
        console.log(chalk.gray('  â”‚') + chalk.green('  [+]') + chalk.white(' Neo initialized') + chalk.gray('                      â”‚'));
        console.log(chalk.gray('  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n'));
    }

    async start() {
        this.displayWelcome();
        await this.mainLoop();
    }

    async mainLoop() {
        while (true) {
            console.log(chalk.gray('  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'));
            const { action } = await prompts.mainMenu();
            console.log(chalk.gray('  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n'));

            switch (action) {
                case 'push':
                    await this.handleSmartPush();
                    break;
                case 'commit':
                    await this.handleSmartCommit();
                    break;
                case 'branch':
                    await this.handleBranchManagement();
                    break;
                case 'merge':
                    await this.handleMerge();
                    break;
                case 'status':
                    await this.handleStatus();
                    break;
                case 'exit':
                    console.log(chalk.gray('\n  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'));
                    console.log(chalk.gray('  [') + chalk.red('!') + chalk.gray('] Exiting the Matrix...'));
                    console.log(chalk.gray('  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n'));
                    process.exit(0);
            }
        }
    }

    async handleSmartPush() {
        const message = await this.getCommitMessage();
        if (!message) return; // User cancelled

        const result = await this.git.smartPush(message);

        if (!result.success) {
            console.log(chalk.red(`\n  [!] ${result.message}\n`));
        }
    }

    async handleSmartCommit() {
        const message = await this.getCommitMessage();
        if (!message) return; // User cancelled

        const result = await this.git.smartCommit(message);

        if (!result.success) {
            console.log(chalk.red(`\n  [!] ${result.message}\n`));
        }
    }

    async getCommitMessage() {
        // Check if AI is available
        if (!this.aiGenerator.isAvailable()) {
            // Fall back to manual input
            const { message } = await prompts.commitMessage();
            return message;
        }

        // Ask user: AI or manual
        const { method } = await prompts.commitMessageWithAI();

        if (method === 'manual') {
            const { message } = await prompts.commitMessage();
            return message;
        }

        // AI method
        const diffResult = await this.git.git.diff();
        if (!diffResult || diffResult.trim().length === 0) {
            console.log(chalk.yellow('\n  [!] No changes to commit\n'));
            return null;
        }

        let aiMessage = null;
        let attempts = 0;
        const maxAttempts = 3;

        while (attempts < maxAttempts) {
            const result = await this.aiGenerator.generateCommitMessage(diffResult);

            if (!result.success) {
                console.log(chalk.red(`\n  [!] ${result.message}\n`));
                const { message } = await prompts.commitMessage();
                return message;
            }

            console.log(chalk.green('\n  ğŸ¤– AI Generated:'));
            console.log(chalk.white(`     "${result.message}"\n`));

            const { action } = await prompts.aiCommitAction(result.message);

            if (action === 'use') {
                return result.message;
            } else if (action === 'edit') {
                const { message } = await prompts.editMessage(result.message);
                return message;
            } else if (action === 'regenerate') {
                attempts++;
                continue;
            } else { // cancel
                return null;
            }
        }

        // Max attempts reached, fall back to manual
        console.log(chalk.yellow('\n  [*] Max regenerations reached, please enter manually\n'));
        const { message } = await prompts.commitMessage();
        return message;
    }

    async handleBranchManagement() {
        while (true) {
            const { action } = await prompts.branchMenu();

            if (action === 'back') break;

            switch (action) {
                case 'list':
                    await this.listBranches();
                    break;
                case 'create':
                    await this.createBranch();
                    break;
                case 'switch':
                    await this.switchBranch();
                    break;
                case 'delete':
                    await this.deleteBranch();
                    break;
            }
        }
    }

    async listBranches() {
        const result = await this.git.listBranches();

        if (result.success) {
            console.log('\n' + chalk.gray('  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'));
            console.log(chalk.green('  [*] BRANCHES'));
            console.log(chalk.gray('  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€'));
            Object.entries(result.branches).forEach(([name, info]) => {
                const prefix = name === result.current ? chalk.green('  â†’  ') : chalk.gray('     ');
                console.log(prefix + chalk.white(name));
            });
            console.log(chalk.gray('  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n'));
        } else {
            console.log(chalk.red(`\n  [!] ERROR: ${result.message}\n`));
        }
    }

    async createBranch() {
        const { name } = await prompts.branchName();
        await this.git.createBranch(name);
    }

    async switchBranch() {
        const branchesResult = await this.git.listBranches();

        if (!branchesResult.success) {
            console.log(chalk.red(`\n  [!] ${branchesResult.message}\n`));
            return;
        }

        const branchList = Object.entries(branchesResult.branches).map(([name, info]) => ({
            name: name,
            current: name === branchesResult.current
        }));

        const { branch } = await prompts.selectBranch(branchList);

        if (branch === branchesResult.current) {
            console.log(chalk.yellow('\n  [!] Already on this branch\n'));
            return;
        }

        await this.git.switchBranch(branch);
    }

    async deleteBranch() {
        const branchesResult = await this.git.listBranches();

        if (!branchesResult.success) {
            console.log(chalk.red(`\n  [!] ${branchesResult.message}\n`));
            return;
        }

        const branchList = Object.entries(branchesResult.branches)
            .filter(([name]) => name !== branchesResult.current)
            .map(([name, info]) => ({
                name: name,
                current: false
            }));

        if (branchList.length === 0) {
            console.log(chalk.yellow('\n  [!] No other branches to delete\n'));
            return;
        }

        const { branch } = await prompts.selectBranch(branchList);
        const { confirmed } = await prompts.confirm(`Delete branch '${branch}'?`);

        if (!confirmed) {
            console.log(chalk.gray('\n  [-] Cancelled\n'));
            return;
        }

        const result = await this.git.deleteBranch(branch);

        if (!result.success && result.message.includes('not fully merged')) {
            const { force } = await prompts.forceDelete();
            if (force) {
                await this.git.deleteBranch(branch, true);
            }
        }
    }

    async handleMerge() {
        const branchesResult = await this.git.listBranches();

        if (!branchesResult.success) {
            console.log(chalk.red(`\n  [!] ERROR: ${branchesResult.message}\n`));
            return;
        }

        const branchList = Object.entries(branchesResult.branches)
            .filter(([name]) => name !== branchesResult.current)
            .map(([name, info]) => ({
                name: name,
                current: false
            }));

        if (branchList.length === 0) {
            console.log(chalk.yellow('\n  [!] No other branches available to merge\n'));
            return;
        }

        const { branch } = await prompts.selectBranch(branchList);
        const result = await this.git.mergeBranch(branch);

        if (!result.success && result.conflicts) {
            console.log('\n' + chalk.gray('  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'));
            console.log(chalk.red('  [!] MERGE CONFLICTS DETECTED'));
            console.log(chalk.gray('  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€'));
            result.conflicts.forEach(file => {
                console.log(chalk.yellow(`      â†’ ${file}`));
            });
            console.log(chalk.gray('  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€'));
            console.log(chalk.gray('  [*] Action required: Resolve conflicts manually'));
            console.log(chalk.gray('  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n'));
        }
    }

    async handleStatus() {
        await this.git.displayStatus();
    }
}

module.exports = UI;
