const simpleGit = require('simple-git');
const chalk = require('chalk');
const ora = require('ora');

class GitOperations {
    constructor(config = null) {
        this.git = simpleGit();
        this.config = config;
    }

    async isGitRepository() {
        try {
            await this.git.checkIsRepo();
            return true;
        } catch (error) {
            return false;
        }
    }

    async hasRemote() {
        try {
            const remotes = await this.git.getRemotes();
            return remotes.length > 0;
        } catch (error) {
            return false;
        }
    }

    async withTimeout(promise, timeoutMs = 30000, operation = 'Operation') {
        const timeoutPromise = new Promise((_, reject) =>
            setTimeout(() => reject(new Error(`${operation} timeout after ${timeoutMs / 1000}s`)), timeoutMs)
        );
        return Promise.race([promise, timeoutPromise]);
    }

    async isMerging() {
        try {
            const status = await this.git.status();
            return status.conflicted.length > 0;
        } catch (error) {
            return false;
        }
    }

    formatCommitMessage(message) {
        if (!this.config || !this.config.commitStyle) {
            return message;
        }

        // If already has a prefix, don't add another
        if (this.config.commitStyle === 'conventional') {
            const conventionalPrefixes = ['feat:', 'fix:', 'docs:', 'style:', 'refactor:', 'test:', 'chore:', 'perf:', 'ci:', 'build:', 'revert:'];
            const hasPrefix = conventionalPrefixes.some(prefix => message.toLowerCase().startsWith(prefix));
            if (!hasPrefix) {
                // Default to 'chore:' if no prefix
                return `chore: ${message}`;
            }
        } else if (this.config.commitStyle === 'custom' && this.config.customPrefix) {
            if (!message.startsWith(this.config.customPrefix)) {
                return `${this.config.customPrefix} ${message}`;
            }
        }

        return message;
    }

    async smartPush(commitMessage) {
        const spinner = ora('Preparing to push...').start();

        try {
            // Check if it's a git repository
            if (!await this.isGitRepository()) {
                spinner.fail(chalk.red('✗ Not a git repository'));
                return { success: false, message: 'Initialize git with: git init' };
            }

            // Check if remote is configured
            if (!await this.hasRemote()) {
                spinner.fail(chalk.red('✗ No remote repository configured'));
                return {
                    success: false,
                    message: 'Add remote with: git remote add origin <repository-url>'
                };
            }

            // Auto-fetch if configured
            if (this.config && this.config.autoFetch) {
                spinner.text = 'Auto-fetching from remote...';
                try {
                    await this.withTimeout(this.git.fetch(), 30000, 'Fetch');
                    spinner.text = 'Preparing to push...';
                } catch (fetchError) {
                    // Continue even if fetch fails
                    spinner.warn(chalk.yellow('⚠ Auto-fetch failed, continuing...'));
                }
            }

            // Check if there are changes
            const status = await this.git.status();

            if (status.files.length === 0) {
                spinner.warn(chalk.yellow('No changes to commit'));
                return { success: false, message: 'No changes detected' };
            }

            // Add all changes
            spinner.text = 'Adding files...';
            await this.git.add('.');

            // Format commit message based on config
            const formattedMessage = this.formatCommitMessage(commitMessage);

            // Commit
            spinner.text = 'Committing changes...';
            await this.git.commit(formattedMessage);

            // Check if current branch has upstream
            const branch = await this.git.branch();
            const currentBranch = branch.branches[branch.current];

            // Push (with upstream setup if needed)
            spinner.text = 'Pushing to remote...';
            if (!currentBranch || !currentBranch.tracking) {
                // First push - set upstream
                await this.withTimeout(
                    this.git.push(['-u', 'origin', branch.current]),
                    30000,
                    'Push'
                );
            } else {
                // Normal push
                await this.withTimeout(this.git.push(), 30000, 'Push');
            }

            spinner.succeed(chalk.green('✓ Successfully pushed!'));
            if (formattedMessage !== commitMessage) {
                console.log(chalk.gray(`  [*] Commit message: ${formattedMessage}`));
            }
            return { success: true, message: 'Changes pushed successfully' };

        } catch (error) {
            spinner.fail(chalk.red('✗ Push failed'));

            // Better error messages
            if (error.message.includes('timeout')) {
                return { success: false, message: 'Push timeout - check your internet connection' };
            } else if (error.message.includes('ETIMEDOUT') || error.message.includes('ENOTFOUND')) {
                return { success: false, message: 'Network error - check your internet connection' };
            } else if (error.message.includes('authentication failed')) {
                return { success: false, message: 'Authentication failed - check your credentials' };
            } else if (error.message.includes('rejected')) {
                return { success: false, message: 'Push rejected - pull remote changes first' };
            }

            return { success: false, message: error.message };
        }
    }

    async smartCommit(commitMessage) {
        const spinner = ora('Preparing to commit...').start();

        try {
            // Check if it's a git repository
            if (!await this.isGitRepository()) {
                spinner.fail(chalk.red('✗ Not a git repository'));
                return { success: false, message: 'Initialize git with: git init' };
            }

            // Auto-fetch if configured
            if (this.config && this.config.autoFetch) {
                spinner.text = 'Auto-fetching from remote...';
                try {
                    await this.withTimeout(this.git.fetch(), 30000, 'Fetch');
                    spinner.text = 'Preparing to commit...';
                } catch (fetchError) {
                    // Continue even if fetch fails
                    spinner.warn(chalk.yellow('⚠ Auto-fetch failed, continuing...'));
                }
            }

            // Check if there are changes
            const status = await this.git.status();

            if (status.files.length === 0) {
                spinner.warn(chalk.yellow('No changes to commit'));
                return { success: false, message: 'No changes detected' };
            }

            // Add all changes
            spinner.text = 'Adding files...';
            await this.git.add('.');

            // Format commit message based on config
            const formattedMessage = this.formatCommitMessage(commitMessage);

            // Commit
            spinner.text = 'Committing changes...';
            await this.git.commit(formattedMessage);

            spinner.succeed(chalk.green('✓ Successfully committed!'));
            if (formattedMessage !== commitMessage) {
                console.log(chalk.gray(`  [*] Commit message: ${formattedMessage}`));
            }

            // Auto-push if configured
            if (this.config && this.config.autoPush) {
                console.log(chalk.gray('  [*] Auto-push enabled, pushing to remote...'));

                // Check if current branch has upstream
                const branch = await this.git.branch();
                const currentBranch = branch.branches[branch.current];

                const pushSpinner = ora('Pushing to remote...').start();
                try {
                    if (!currentBranch || !currentBranch.tracking) {
                        // First push - set upstream
                        await this.withTimeout(
                            this.git.push(['-u', 'origin', branch.current]),
                            30000,
                            'Push'
                        );
                    } else {
                        // Normal push
                        await this.withTimeout(this.git.push(), 30000, 'Push');
                    }
                    pushSpinner.succeed(chalk.green('✓ Auto-pushed successfully!'));
                } catch (pushError) {
                    pushSpinner.fail(chalk.yellow('⚠ Auto-push failed'));
                    console.log(chalk.gray('  [*] Run ') + chalk.white('git-neo push') + chalk.gray(' manually'));
                }
            } else {
                // Show next step hint if autoPush is disabled
                console.log(chalk.gray('  [*] Tip: Run ') + chalk.white('git-neo push') + chalk.gray(' to push changes'));
            }

            return { success: true, message: 'Changes committed successfully' };

        } catch (error) {
            spinner.fail(chalk.red('✗ Commit failed'));
            return { success: false, message: error.message };
        }
    }

    async listBranches() {
        try {
            const branches = await this.git.branch();
            return {
                success: true,
                current: branches.current,
                all: branches.all,
                branches: branches.branches
            };
        } catch (error) {
            return { success: false, message: error.message };
        }
    }

    async createBranch(branchName) {
        const spinner = ora(`Creating branch '${branchName}'...`).start();

        try {
            await this.git.checkoutLocalBranch(branchName);
            spinner.succeed(chalk.green(`✓ Branch '${branchName}' created and checked out`));
            return { success: true, message: `Branch ${branchName} created` };
        } catch (error) {
            spinner.fail(chalk.red(`✗ Failed to create branch '${branchName}'`));
            return { success: false, message: error.message };
        }
    }

    async switchBranch(branchName) {
        const spinner = ora(`Switching to branch '${branchName}'...`).start();

        try {
            await this.git.checkout(branchName);
            spinner.succeed(chalk.green(`✓ Switched to branch '${branchName}'`));
            return { success: true, message: `Switched to ${branchName}` };
        } catch (error) {
            spinner.fail(chalk.red(`✗ Failed to switch to '${branchName}'`));
            return { success: false, message: error.message };
        }
    }

    async deleteBranch(branchName, force = false) {
        const spinner = ora(`Deleting branch '${branchName}'...`).start();

        try {
            await this.git.deleteLocalBranch(branchName, force);
            spinner.succeed(chalk.green(`✓ Branch '${branchName}' deleted`));
            return { success: true, message: `Branch ${branchName} deleted` };
        } catch (error) {
            spinner.fail(chalk.red(`✗ Failed to delete branch '${branchName}'`));
            return { success: false, message: error.message };
        }
    }

    async mergeBranch(branchName) {
        const spinner = ora(`Merging branch '${branchName}'...`).start();

        try {
            const result = await this.git.merge([branchName]);

            if (result.conflicts.length > 0) {
                spinner.warn(chalk.yellow(`⚠ Merge conflicts detected in ${result.conflicts.length} file(s)`));
                return {
                    success: false,
                    conflicts: result.conflicts,
                    message: 'Merge conflicts need to be resolved'
                };
            }

            spinner.succeed(chalk.green(`✓ Successfully merged '${branchName}'`));
            return { success: true, message: `Merged ${branchName}` };
        } catch (error) {
            spinner.fail(chalk.red(`✗ Failed to merge '${branchName}'`));
            return { success: false, message: error.message };
        }
    }

    async abortMerge() {
        const spinner = ora('Aborting merge...').start();

        try {
            await this.git.merge(['--abort']);
            spinner.succeed(chalk.green('✓ Merge aborted'));
            return { success: true, message: 'Merge aborted successfully' };
        } catch (error) {
            spinner.fail(chalk.red('✗ Failed to abort merge'));
            return { success: false, message: error.message };
        }
    }

    async getStatus() {
        try {
            const status = await this.git.status();
            return {
                success: true,
                status: status
            };
        } catch (error) {
            return { success: false, message: error.message };
        }
    }

    async displayStatus() {
        const spinner = ora('Fetching status...').start();

        try {
            const status = await this.git.status();
            spinner.stop();

            console.log('\n' + chalk.bold.cyan('=== Git Status ===\n'));
            console.log(chalk.bold('Branch: ') + chalk.green(status.current));
            console.log(chalk.bold('Tracking: ') + (status.tracking || chalk.gray('Not tracking')));

            if (status.ahead > 0) {
                console.log(chalk.yellow(`↑ ${status.ahead} commit(s) ahead`));
            }
            if (status.behind > 0) {
                console.log(chalk.yellow(`↓ ${status.behind} commit(s) behind`));
            }

            if (status.files.length > 0) {
                console.log('\n' + chalk.bold('Changes:'));
                status.files.forEach(file => {
                    const symbol = this._getFileStatusSymbol(file);
                    console.log(`  ${symbol} ${file.path}`);
                });
            } else {
                console.log('\n' + chalk.green('✓ Working tree clean'));
            }

            console.log('');
            return { success: true };
        } catch (error) {
            spinner.fail(chalk.red('✗ Failed to get status'));
            return { success: false, message: error.message };
        }
    }

    _getFileStatusSymbol(file) {
        if (file.working_dir === 'M') return chalk.yellow('M');
        if (file.working_dir === 'D') return chalk.red('D');
        if (file.working_dir === '?') return chalk.gray('?');
        if (file.index === 'A') return chalk.green('A');
        if (file.index === 'M') return chalk.green('M');
        return chalk.gray('·');
    }

    // Basic Git Commands
    async pull(remote = 'origin', branch = null) {
        const spinner = ora('Pulling changes...').start();

        try {
            const branchInfo = await this.git.branch();
            const branchName = branch || (this.config && this.config.defaultBranch) || branchInfo.current;

            // Check if branch has upstream
            if (!branch && branchInfo.branches[branchInfo.current]) {
                const tracking = branchInfo.branches[branchInfo.current].tracking;
                if (!tracking) {
                    spinner.fail(chalk.red('✗ Current branch has no upstream'));
                    return {
                        success: false,
                        message: `Set upstream with: git push -u ${remote} ${branchName}`
                    };
                }
            }

            await this.withTimeout(this.git.pull(remote, branchName), 30000, 'Pull');
            spinner.succeed(chalk.green(`✓ Pulled from ${remote}/${branchName}`));
            return { success: true, message: 'Pull successful' };
        } catch (error) {
            spinner.fail(chalk.red('✗ Pull failed'));

            if (error.message.includes('timeout')) {
                return { success: false, message: 'Pull timeout - check your internet connection' };
            }

            return { success: false, message: error.message };
        }
    }

    async clone(repoUrl, targetDir = null) {
        const spinner = ora(`Cloning ${repoUrl}...`).start();

        try {
            await this.withTimeout(
                this.git.clone(repoUrl, targetDir),
                60000, // 60 seconds for clone
                'Clone'
            );
            spinner.succeed(chalk.green('✓ Repository cloned successfully'));
            return { success: true, message: 'Clone successful' };
        } catch (error) {
            spinner.fail(chalk.red('✗ Clone failed'));

            if (error.message.includes('timeout')) {
                return { success: false, message: 'Clone timeout - repository may be too large or network is slow' };
            }

            return { success: false, message: error.message };
        }
    }

    async init() {
        const spinner = ora('Initializing Git repository...').start();

        try {
            await this.git.init();
            spinner.succeed(chalk.green('✓ Git repository initialized'));
            return { success: true, message: 'Init successful' };
        } catch (error) {
            spinner.fail(chalk.red('✗ Init failed'));
            return { success: false, message: error.message };
        }
    }

    async log(count = 10) {
        const spinner = ora('Fetching commit history...').start();

        try {
            const logs = await this.git.log({ maxCount: count });
            spinner.stop();

            console.log('\n' + chalk.bold.cyan('=== Commit History ===\n'));

            if (logs.all.length === 0) {
                console.log(chalk.gray('No commits yet\n'));
                return { success: true, logs: [] };
            }

            logs.all.forEach((commit, index) => {
                console.log(chalk.yellow(`${commit.hash.substring(0, 7)}`) + chalk.gray(' - ') + commit.message);
                console.log(chalk.gray(`  ${commit.author_name} <${commit.author_email}>`));
                console.log(chalk.gray(`  ${new Date(commit.date).toLocaleString()}\n`));
            });

            return { success: true, logs: logs.all };
        } catch (error) {
            spinner.fail(chalk.red('✗ Failed to fetch logs'));
            return { success: false, message: error.message };
        }
    }

    async diff(file = null) {
        const spinner = ora('Fetching diff...').start();

        try {
            const diffSummary = file ? await this.git.diff([file]) : await this.git.diff();
            spinner.stop();

            if (!diffSummary) {
                console.log(chalk.gray('\nNo changes\n'));
                return { success: true, diff: '' };
            }

            console.log('\n' + chalk.bold.cyan('=== Changes ===\n'));
            console.log(diffSummary);
            console.log('');

            return { success: true, diff: diffSummary };
        } catch (error) {
            spinner.fail(chalk.red('✗ Failed to get diff'));
            return { success: false, message: error.message };
        }
    }

    async fetch(remote = 'origin') {
        const spinner = ora(`Fetching from ${remote}...`).start();

        try {
            await this.withTimeout(this.git.fetch(remote), 30000, 'Fetch');
            spinner.succeed(chalk.green(`✓ Fetched from ${remote}`));
            return { success: true, message: 'Fetch successful' };
        } catch (error) {
            spinner.fail(chalk.red('✗ Fetch failed'));

            if (error.message.includes('timeout')) {
                return { success: false, message: 'Fetch timeout - check your internet connection' };
            }

            return { success: false, message: error.message };
        }
    }
}

module.exports = GitOperations;
