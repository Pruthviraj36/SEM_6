const inquirer = require('inquirer');
const chalk = require('chalk');

const prompts = {
    mainMenu: async () => {
        return inquirer.prompt([
            {
                type: 'list',
                name: 'action',
                message: chalk.green('[') + chalk.white('SELECT OPERATION') + chalk.green(']'),
                choices: [
                    { name: chalk.green('[1]') + chalk.white(' Smart Push') + chalk.gray(' â†’ add, commit, push'), value: 'push' },
                    { name: chalk.green('[2]') + chalk.white(' Commit') + chalk.gray(' â†’ add, commit (no push)'), value: 'commit' },
                    { name: chalk.green('[3]') + chalk.white(' Branch Management') + chalk.gray(' â†’ create, switch, delete'), value: 'branch' },
                    { name: chalk.green('[4]') + chalk.white(' Merge Branch') + chalk.gray(' â†’ merge operations'), value: 'merge' },
                    { name: chalk.green('[5]') + chalk.white(' Repository Status') + chalk.gray(' â†’ view changes'), value: 'status' },
                    { name: chalk.red('[X]') + chalk.white(' Exit'), value: 'exit' }
                ]
            }
        ]);
    },

    commitMessage: async () => {
        return inquirer.prompt([
            {
                type: 'input',
                name: 'message',
                message: chalk.green('[') + chalk.white('COMMIT MESSAGE') + chalk.green(']'),
                validate: (input) => {
                    if (input.trim().length === 0) {
                        return chalk.red('[!] Commit message cannot be empty');
                    }
                    return true;
                }
            }
        ]);
    },

    commitMessageWithAI: async () => {
        return inquirer.prompt([
            {
                type: 'list',
                name: 'method',
                message: chalk.green('[') + chalk.white('COMMIT MESSAGE') + chalk.green(']'),
                choices: [
                    { name: chalk.cyan('ðŸ¤– Generate with AI'), value: 'ai' },
                    { name: chalk.white('âœï¸  Write manually'), value: 'manual' }
                ]
            }
        ]);
    },

    aiCommitAction: async (message) => {
        return inquirer.prompt([
            {
                type: 'list',
                name: 'action',
                message: chalk.green('[') + chalk.white('AI SUGGESTION') + chalk.green(']') + chalk.gray(` "${message}"`),
                choices: [
                    { name: chalk.green('âœ“ Use this message'), value: 'use' },
                    { name: chalk.yellow('âœŽ Edit this message'), value: 'edit' },
                    { name: chalk.cyan('â†» Generate new message'), value: 'regenerate' },
                    { name: chalk.red('âœ— Cancel'), value: 'cancel' }
                ]
            }
        ]);
    },

    editMessage: async (defaultMessage) => {
        return inquirer.prompt([
            {
                type: 'input',
                name: 'message',
                message: chalk.green('[') + chalk.white('EDIT MESSAGE') + chalk.green(']'),
                default: defaultMessage,
                validate: (input) => {
                    if (input.trim().length === 0) {
                        return chalk.red('[!] Commit message cannot be empty');
                    }
                    return true;
                }
            }
        ]);
    },

    branchMenu: async () => {
        return inquirer.prompt([
            {
                type: 'list',
                name: 'action',
                message: chalk.green('[') + chalk.white('BRANCH OPERATIONS') + chalk.green(']'),
                choices: [
                    { name: chalk.green('[L]') + chalk.white(' List branches') + chalk.gray(' â†’ show all'), value: 'list' },
                    { name: chalk.green('[C]') + chalk.white(' Create new branch') + chalk.gray(' â†’ checkout new'), value: 'create' },
                    { name: chalk.green('[S]') + chalk.white(' Switch branch') + chalk.gray(' â†’ checkout existing'), value: 'switch' },
                    { name: chalk.red('[D]') + chalk.white(' Delete branch') + chalk.gray(' â†’ remove'), value: 'delete' },
                    { name: chalk.gray('[â†]') + chalk.white(' Back'), value: 'back' }
                ]
            }
        ]);
    },

    branchName: async () => {
        return inquirer.prompt([
            {
                type: 'input',
                name: 'name',
                message: chalk.green('[') + chalk.white('BRANCH NAME') + chalk.green(']'),
                validate: (input) => {
                    if (input.trim().length === 0) {
                        return chalk.red('[!] Branch name cannot be empty');
                    }

                    // Git branch name rules
                    if (input.startsWith('-') || input.startsWith('.')) {
                        return chalk.red('[!] Cannot start with - or .');
                    }
                    if (input.endsWith('.lock') || input.endsWith('.')) {
                        return chalk.red('[!] Cannot end with .lock or .');
                    }
                    if (input.includes('..') || input.includes('@{') || input.includes('//')) {
                        return chalk.red('[!] Invalid sequence: .., @{, or //');
                    }
                    if (input.includes(' ')) {
                        return chalk.red('[!] Branch names cannot contain spaces');
                    }
                    if (input.includes('~') || input.includes('^') || input.includes(':')) {
                        return chalk.red('[!] Invalid characters: ~, ^, or :');
                    }
                    if (!/^[a-zA-Z0-9/_.-]+$/.test(input)) {
                        return chalk.red('[!] Invalid characters (use: a-z, 0-9, /, -, _, .)');
                    }
                    if (input.length > 255) {
                        return chalk.red('[!] Branch name too long (max 255 characters)');
                    }

                    return true;
                }
            }
        ]);
    },

    selectBranch: async (branches) => {
        return inquirer.prompt([
            {
                type: 'list',
                name: 'branch',
                message: chalk.green('[') + chalk.white('SELECT BRANCH') + chalk.green(']'),
                choices: branches.map(b => ({
                    name: b.current ? chalk.green('â†’ ') + chalk.white(b.name) : chalk.gray('  ') + chalk.white(b.name),
                    value: b.name
                }))
            }
        ]);
    },

    confirm: async (message) => {
        return inquirer.prompt([
            {
                type: 'confirm',
                name: 'confirmed',
                message: chalk.yellow('[?] ') + chalk.white(message),
                default: false
            }
        ]);
    },

    forceDelete: async () => {
        return inquirer.prompt([
            {
                type: 'confirm',
                name: 'force',
                message: chalk.red('[!] ') + chalk.white('Branch has unmerged changes. Force delete?'),
                default: false
            }
        ]);
    }
};

module.exports = prompts;
