const fs = require('fs');
const path = require('path');
const chalk = require('chalk');

class Config {
    constructor() {
        this.configFileName = '.gitkit.json';
        this.configPath = path.join(process.cwd(), this.configFileName);
    }

    configExists() {
        return fs.existsSync(this.configPath);
    }

    loadConfig() {
        try {
            if (!this.configExists()) {
                return null;
            }
            const data = fs.readFileSync(this.configPath, 'utf8');
            return JSON.parse(data);
        } catch (error) {
            if (error instanceof SyntaxError) {
                console.error(chalk.red('\n  [!] Error: .gitkit.json is corrupted or contains invalid JSON'));
                console.error(chalk.yellow('  [*] Tip: Delete .gitkit.json and run "git-neo setup" to reconfigure\n'));
            } else if (error.code === 'EACCES') {
                console.error(chalk.red('\n  [!] Error: Permission denied reading .gitkit.json\n'));
            } else {
                console.error(chalk.red('\n  [!] Error loading config:'), error.message + '\n');
            }
            return null;
        }
    }

    saveConfig(config) {
        try {
            const data = JSON.stringify(config, null, 2);
            fs.writeFileSync(this.configPath, data, 'utf8');
            return true;
        } catch (error) {
            if (error.code === 'EACCES') {
                console.error(chalk.red('\n  [!] Error: Permission denied writing to .gitkit.json'));
                console.error(chalk.yellow('  [*] Tip: Check file permissions or run with appropriate privileges\n'));
            } else if (error.code === 'EROFS') {
                console.error(chalk.red('\n  [!] Error: Read-only file system\n'));
            } else {
                console.error(chalk.red('\n  [!] Error saving config:'), error.message + '\n');
            }
            return false;
        }
    }

    getConfig(key) {
        const config = this.loadConfig();
        if (!config) return null;
        return key ? config[key] : config;
    }

    updateConfig(updates) {
        const config = this.loadConfig() || {};
        const newConfig = { ...config, ...updates };
        return this.saveConfig(newConfig);
    }

    deleteConfig() {
        try {
            if (this.configExists()) {
                fs.unlinkSync(this.configPath);
                return true;
            }
            return false;
        } catch (error) {
            console.error('Error deleting config:', error.message);
            return false;
        }
    }
}

module.exports = Config;
